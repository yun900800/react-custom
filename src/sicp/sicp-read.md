# SICP 读书心得以及经典文章

1. 什么是编程?是我们对问题思考过程的**形式化描述**

2. 什么是**形式化描述**,之按照一定的规则对事物进行描述;对程序员而言,这个规则就是所使用的编程语言的语法规则.

3. 这是一本能不断突破原有视角的桎梏,进入全新领域来重新审视关于计算和计算机的思考.连续的头脑风暴带来的尤里卡时刻总是给人带来无上的精神享受

4. 两个核心思想:
    - 程序首先是给人读的,只是恰好能够被机器执行.
    - 与程序而言,最最重要的是控制软件的复杂度;相比之下，算法和数据结构在此之后.

5. 几个重要的概念:
    - wishful thinking（按愿望编程）
        1. 书写递归的必备思想
        2. 真正接收这个思想的时候,你的设计自然就会变成依赖于抽象,自然而然达到松耦合
        3. 经典的例子就是汉诺塔,用四阶为例
            - 先将前三个移动到中转位置
            - 再将最后一个移动到目标位置
            - 再将最后一个移动到目标位置
        4. 为什么我们可以这么做?为什么我们可以这么去假设?这么去wishful thinking?
            - 因为我们在减小问题的规模
            - 我们将问题从移动四个，变成了移动三个
            - 依此递归下去，我们最终就能将问题减小到可以一步解决
            - 依此递归下去，我们最终就能将问题减小到可以一步解决
    - layer system（按层次划分系统)
        1. 应对需求变更的终极大招。
        2. 我们将系统构建成一个layer system的目的就是为了当外界需求发生变化时， 我只需要修改某一层的某一部分， 而这一层的上下层都对这个变化没有感知。
        3. layer system的基本思想是上面一层完全依托于下面一层的api进行构建， 也就是说，其实在layer system中每一层都是拥有构建完整系统的能力的。
        4. 当新需求到来时，如果发现在上一层无法被解决， 我们就可以进行降层， 在下面一层尝试进行解决. 最终将需求就被限定到一个尽量小的范围。
        5. 这种思路在所有的大型软件中都能看到， linux就是最好的例子。
    - Abstract（抽象）
        1. it is not for machine, it is for human. because our brain can not put all things in it at once。
        2. 很早以前开始软件的复杂度就已经大大超出了人类大脑所能控制的范围，再明确一些就是如果你想将这些软件的细节一次性地都放进你的大脑，这是绝无可能。
        3. 所以我们需要一些方法， 而这些方法并不是软件行业独创的， 而是人类使用大脑思考以来就一直在使用的方法. Abstract就是这其中非常关键的一种.
        4. 正是有了Abstract， 在软件规模继续保持暴增的情况下， 人类依然牢牢掌握着主动权。
        5. 抽象其实无处不在， 一提到抽象就想到接口， 抽象类。其实变量名，方法就是一种抽象。抽象的另外一层意思就是要学会去忽略细节。就像上面提到的， 软件里最终是要构建一个layer system， 这样就能做到最小化改变适用新需求. 而这个layer system的表现就是：
            - 不论你处在抽象层次中的哪一层 ，当你对底层进行分析查看 ，就会发现依然无数的抽象层次的存在。
            - 不论你处在抽象层次中的哪一层 ，当你对底层进行分析查看 ，就会发现依然无数的抽象层次的存在。
            - 理解复杂事物的关键之一就在于：你需要清楚知道应该忽略掉那些次要的东西，而将注意力集中到那些真正需要考虑的事物上。
    - 推迟作决定的时机
        1. 很多时候我们不想要被此时的决定束缚住手脚，导致之后的工作因当前的决定而步履维艰。但我们又必须作出某种决定以便让接下来的工作得以进行，于是我们可以假装实现了这个功能（假装已经做出了这个决定，Wishful Thinking）来让工作得以继续；待到真正需要这个功能时，才去实现它（真正地做出来决定）。使用这种方法可以让我们的程序变得非常稳固，能够自如地应对外界的变化。
        2. “面向接口编程”，相信此类言论已经被你们听烂了吧。那我给一种新的解释，希望能带来一点不一样的感悟 —— 建立接口的目的就是为了推迟作决定的时机。
            - 定义接口就是假装作出了这个决定
            - 定义接口就是假装作出了这个决定
            - 而实现接口则是真正地作出这个决定。
            - 熟悉Java的同学应该都知道多态属于一种"动态绑定"吧。所谓的动态绑定不就是到真正需要的时候才去找实现者吗？
            - 而我们所熟悉的反射也是“推迟作决定的时机” 又一佐证。
    - 高阶函数
        1. 接受这种思想的结果就是极度模糊化 data与function之间的界限。
            - 高阶函数让我们拥有了更高的抽象层次。
            - 通过接收function， 我们即可以实现多态的功能。这也符合OOP指导思想中的"使用组合代替继承"。
            - 在下面要讲到的Stream Process中你会发现， 为了达到和命令式编程一样的性能，我们就需要求助于这种思想。
        2. 理解递归中的尾递归以及什么是尾调用,怎么样将普通递归转化成尾递归, APS和CPS是怎么样转化尾递归的
    - Stream Process（流式处理）
        1. 

6. sicp序言笔记
    - 社会中的人分为两类:做规划的人和被规划的人;如果做规划当做一种智力活动来欣赏,那么要做好规划，你就一定要会写程序
    - 程序员想要写出优雅的程序,基础的两点有:具体部分的完美性和汇合部分的适宜性
    - 写程序除了适宜性，一致性和正确性之外，另一个关键就是将结构组合成更大结构的有价值的组织技术
    - 程序的性能关注两点:执行的时间和对数据存储的要求
    - Lisp 和 Pascal两类语言的差异，以及优缺点
        > Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to always see it as a soap bubble?

        怎么理解这句话?大师的话语总是云里雾里的
    - 将计算机和小提琴类比说明了想要写好程序是很容易的,但是写出优秀的程序是很难的,因此就有了一种说法叫做程序设计很容易成为一种媒介,用于表述理解肤浅,草率而就得思想. 小提琴或者计算机缺乏弹性是因为那是在我们还没有学会如何去使用之前.
    - 计算机语言不仅仅是让计算机去执行操作的一种方式,而是一种表达有关方法学的思想的新颖的媒介; 其次这一层次的学习，不是程序设计语言的语法,不是有效计算某种功能的巧妙算法,不是算法的数学分析或者计算的本质基础，而是**一些能够用于控制大型软件系统的智力复杂性的技术**.一下是一些使用频率很高的词:
        1. 隐藏细节
        2. 创建抽象
        3. 建立约定界面
        4. "混合与匹配"的方式组合
        5. 关键:有关我们如何去思考的方式以及我们如何去表达自己的思考
        6. 过程性抽象
        7. 数据抽象
        8. 高阶函数的公共模式
        9. 赋值和数据操作模拟局部状态
        10. 流和延时求值
    - 思考需要进入真正的问题:弄清楚我们需要去计算什么?怎样将问题分解为一组可以控制的部分,如何对这样的部分开展工作.
    - 计算是一种探索各种思想的表达方式的手段
    - 大型系统的构造，应该避免控制中的复杂性,将精力集中到数据的组织上，以反映所模拟世界的真实结构(这个点有一点疑问??????)
    - 将过程本身作为数据来表示和操作，这样的特性填平了被动的数据和主动的过程之间的鸿沟，其实在本质上它们是一致的,可以称作计算对象(操作符和操作数)

7. 怎样将过程性思维的有关问题给隔离出来?

8. 语言中的第一组基本元素,组合,抽象
    - 数和算数运算构成基本的元素(基本数据和过程)
    - 组合式的嵌套提供了组织起多个操作的方法(实际上就是一种组合)
    - 定义提供了一种简单受限的抽象手段;而过程定义提供了一种更加强大的抽象

    - 总结一下: 有了过程定义抽象以后，这种抽象在一定的层次上又形成了基本的元素,基本元素又可以进行组合,从而构成更高层次的抽象
9. 应用序和正则序的区别是,应用序先求值，然后计算; 正则序是先展开不求值，需要的时候才求值;
10. 数学函数和计算过程之间的一个重要差异是计算过程必须是有效可行的;抽象出来就是说明性的知识与行动性的知识之间的差异
    - 说明性和行动性描述之间存在内在联系,说明性为行动性提供指导,并且能够为行动性提供正确性判断;而行动性描述能够丰富说明性的知识;它们之间总是转来转去;一个理想的情况就是给出说明性,计算机推断出行动性的描述;比如现在的AI

11. 练习题1.16 将if判断写成了一个过程,如果这个过程不牵涉到递归调用,一般来说没啥问题,如果涉及到啦，就会死循环，因为应用序会前求值每个子表达式
